イベントとイベントディスパッチャ
===============================

プロジェクトのために書かれたコードを拡張することを保証するために
オブジェクト指向プログラミングの方法論は長い道のりをたどってきました。
上手に定義された責務を担うクラスを作成することで、
コードはより柔軟になります。

ユーザーがクラスの振る舞いを修正したい場合、振る舞いをオーバーライドする
サブクラスを使うことで拡張できます。しかし振る舞いを変更するために
独自クラスを作成したユーザーが他のユーザーとその変更を共有したい場合、
コードの継承は価値を失います。

実際の世界の例はクラスにプラグインシステムを提供したいときです。
プラグインはメソッドが実行される前後で、他のプラグインに干渉せず、
メソッドを追加もしくは何かを行うことができるようになります。
これは単一継承で解決できる簡単な問題ではなく、
多重継承(以前のPHPでは可能だった)は欠点を抱えています。

Symfony Event Dispatcherに入ります。このライブラリは
これらすべてのことを可能にしプロジェクトを本当に拡張可能にする
シンプルで効率的な方法で(実現可能なこれらのパターンの実装に関しては
下記のセクションを参照)[Observer](http://en.wikipedia.org/wiki/Observer_pattern)パターンを実装します。

Symfony Event Dispatcherのメインゴールは複数のオブジェクトが
お互いに知らなくてもコミュニケーションできるようにすることです。これは
中心的なオブジェクトである、*ディスパッチャ*のおかげで可能です。

オブジェクト(*リスナー*)は特定のイベントをリスニングするディスパッチャに*接続*可能で、
他のオブジェクトはディスパッチャに*イベント*を*通知*できます。
イベントが通知されるたびに、ディスパッチャは
リスナーを呼び出します。

イベント
-------

他の多くのObserverの実装とは異なり、 
新しいイベントを作成するクラスを作成する必要はありません。
もちろんすべてのイベントはオブジェクトですが、 
しかしすべてのイベントは組み込みの`sfEvent`クラスの
インスタンスです。

>**NOTE**
>もちろん、さらにイベントを特化する、もしくは制約を強制するために
>`sfEvent`クラスを拡張できますが、大抵の場合必要の無い新しいレベルの複雑性を
>追加することになります。

イベントは文字列によって一意的に識別されます。慣習では、イベントの名前に
小文字、数字とアンダースコア(`_`)を使うのがベターです。
さらに、イベントをより上手に編成するには、
ドット(`.`)に続く名前空間を
イベント名の接頭辞として追加することです。

よいイベントの名前の例は次の通りです:

    [php]
    change_culture
    response.filter_content

お気づきのように、イベントの名前にはイベントが関連する
内容を示す動詞が含まれます。

ディスパッチャ
--------------

ディスパッチャはリスナーの登録とイベントが通知されたときに
これらのリスナーを呼び出す責務を担うオブジェクトです。

デフォルトでは、ディスパッチャクラスは`sfEventDispatcher`です:

    [php]
    $dispatcher = new sfEventDispatcher();

イベントオブジェクト
-------------------

イベントオブジェクトである、`sfEvent`クラス、は
通知されたイベントに関する情報を保存します。このコンストラクタは3つの引数を受け取ります:

  * イベントの*subject*(大抵の場合、これはイベントを通知する
    オブジェクトで、`null`にもなります);

  * イベントの名前;

  * リスナーに渡すパラメータの配列(デフォルトでは
    空の配列)。

大抵の場合、イベントはオブジェクトのコンテキストから呼び出され、
大抵の場合最初の引数は`$this`です:

    [php]
    $event = new sfEvent($this, 'user.change_culture', array('culture' => $culture));

イベントオブジェクトはイベント情報を取得するためのメソッドをいくつか持ちます:

  * `getName()`: イベントの識別子を返す。

  * `getSubject()`: イベントにアタッチされるsubjectオブジェクトを取得する。

  * `getParameters()`: イベントのパラメータを返す。

イベントオブジェクトのパラメータを取得するために配列としてアクセスすることも
できます:

    [php]
    echo $event['culture'];

リスナーに接続する
-----------------

明らかに、ディスパッチャの前にディスパッチャにリスナーを接続させるのは便利です。
ディスパッチャの`connect()`メソッドへの呼び出し
はPHP callableをイベントに関連付けます。

`connect()`メソッドは2つの引数を受け取ります:

  * イベントの名前。

  * イベントが通知されるときに呼び出されるPHP callable。

>**NOTE**
>[PHP callable](http://www.php.net/manual/function.is-callable.php)
>はPHP変数で`call_user_func()`関数によって使われ
>`is_callable()`関数に渡されるときに`true`を返します。
>文字列は関数を表し、配列はオブジェクトメソッドもしくは
>クラスメソッドを表すことができます。

    [php]
    $dispatcher->connect('user.change_culture', $callable);

リスナーがイベントディスパッチャに登録されると、イベントが通知されるまで
リスナーは待機します。イベントディスパッチャはすべてのイベントリスナーのレコードを保持し、
イベントが通知されるときに呼び出すものがどれであるか知っています。

>**NOTE**
>リスナーは接続した順序と同じ順序で
>イベントディスパッチャによって呼び出されます。

上記の例に関して、`user.change_culture`イベントがオブジェクトによって通知されるたびに
`$callable`はディスパッチャによって呼び出されます。

リスナーを呼び出すとき、ディスパッチャはこれらにパラメータとして`sfEvent`オブジェクトを
渡します。ですので、リスナーは最初の引数としてイベントオブジェクト
を受け取ります。

イベントを通知する
-----------------

3つのメソッドを使うことでイベントを通知できます:

 * `notify()`
 * `notifyUntil()`
 * `filter()`

### notify

`notify()`メソッドはすべてのリスナーを次々と通知します。

    [php]
    $dispatcher->notify($event);

`notify()`メソッドを使うことで、通知されるイベントに
登録されたすべてのイベントが実行されsubjectに値を
返すことができないことを確認できます。

### notifyUntil

いくつかのケースの場合、リスナーがイベントを停止してリスナーが
さらに通知されるのを防ぐことができるようにする必要があります。 
このケースの場合、`notify()`の代わりに`notifyUntil()`を使います。
ディスパッチャはリスナーの1つが`true`を返すまですべてのリスナーを実行し、
イベント通知を停止します:

    [php]
    $dispatcher->notifyUntil($event);

チェーンを停止させるリスナーは値をsubjectに戻すために`setReturnValue()`メソッドを
呼び出すこともあります。

notifierは`isProcessed()`メソッドを呼び出すことで
リスナーがイベントを処理したかチェックできます:

    [php]
    if ($event->isProcessed())
    {
      $ret = $event->getReturnValue();

      // ...
    }

### filter

`filter()`メソッドはnotifierによって2番目の引数として渡され、
2番目の引数としてリスナーのcallableによって読み取られる値を
フィルタリングするようにすべてのリスナーに指示します:

    [php]
    $dispatcher->filter($event, $response->getContent());

すべてのリスナーには値が渡されこれらは値が変更されたか関わらず
フィルタリングされた値を返さなければなりません。
すべてのリスナーが実行されることが
保証されます。

notifierは`getReturnValue()`メソッドを呼び出すことで
フィルタリングされた値を取得できます:

    [php]
    $ret = $event->getReturnValue();
